AppDbContext.cs: ```using Microsoft.EntityFrameworkCore;
using System;

public class AppDbContext : DbContext
{
    // DbSet definitions for your entities
    public DbSet<Employee> Employees { get; set; }
    public DbSet<Project> Projects { get; set; }
    public DbSet<Customer> Customers { get; set; }
    public DbSet<ProjectCustomer> ProjectCustomers { get; set; }
    public DbSet<EmployeeHierarchy> EmployeeHierarchies { get; set; }
    public DbSet<ProjectSummaryDto> ProjectSummaries { get; set; } // For read-only view

    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configuring ProjectSummaryDto to map to a database view
        modelBuilder.Entity<ProjectSummaryDto>()
            .HasNoKey()
            .ToView("ProjectSummaries");

        // Example configurations for other entities

        // Employee entity configuration
        modelBuilder.Entity<Employee>(entity =>
        {
            entity.ToTable("Employees");
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Department).IsRequired().HasMaxLength(20);
            // Configure one-to-many or many-to-many relationships here
            // Example for one-to-many: Employee to Projects
            entity.HasMany(e => e.AssignedProjects)
                  .WithOne(p => p.Employee)
                  .HasForeignKey(p => p.EmployeeAssigned);
        });

        // Project entity configuration
        modelBuilder.Entity<Project>(entity =>
        {
            entity.ToTable("Projects");
            entity.HasKey(p => p.Id);
            entity.Property(p => p.Name).IsRequired().HasMaxLength(50);
            entity.Property(p => p.Budget).HasColumnType("decimal(19, 4)");
            // If using enums and want to store them as string
            entity.Property(e => e.Status)
                  .HasConversion<string>();
            // Relationships are configured in the Employee entity
        });

        // Customer entity configuration
        modelBuilder.Entity<Customer>(entity =>
        {
            entity.ToTable("Customers");
            entity.HasKey(c => c.Id);
            entity.Property(c => c.Name).IsRequired().HasMaxLength(50);
            entity.Property(c => c.Email).IsRequired().HasMaxLength(254);
            // JSON column configuration, if using SQL Server or a database that supports JSON columns
            entity.Property(c => c.JSONData).HasColumnType("nvarchar(max)");
        });

    }

    public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        var entries = ChangeTracker
            .Entries()
            .Where(e => e.Entity is ITrackable &&
                        (e.State == EntityState.Added || e.State == EntityState.Modified));

        foreach (var entityEntry in entries)
        {
            var now = DateTime.UtcNow;
            ((ITrackable)entityEntry.Entity).UpdatedOn = now;
            ((ITrackable)entityEntry.Entity).CreatedOn = now;

        }

        return await base.SaveChangesAsync(cancellationToken);
    }
}
```

EfCoreTransaction.cs: ```public class EfCoreTransaction : ITransaction
{
    private readonly IDbContextTransaction _dbContextTransaction;

    public EfCoreTransaction(IDbContextTransaction dbContextTransaction)
    {
        _dbContextTransaction = dbContextTransaction;
    }

    public async Task CommitAsync()
    {
        await _dbContextTransaction.CommitAsync();
    }

    public async Task RollbackAsync()
    {
        await _dbContextTransaction.RollbackAsync();
    }

    public void Dispose()
    {
        _dbContextTransaction.Dispose();
    }
}
```

EmployeeProjectRepository.cs: ```using Microsoft.EntityFrameworkCore;
using NetTopologySuite;
using NetTopologySuite.Geometries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Text.Json;

public class EmployeeProjectRepository : IEmployeeProjectRepository
{
    private readonly AppDbContext _context;

    public EmployeeProjectRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task AddEmployee(EmployeeAddDto employeeDto)
    {
        var employee = new Employee
        {
            Id = employeeDto.EmployeeID,
            Name = employeeDto.Name,
            Age = employeeDto.Age,
            Department = employeeDto.Department,
            HireDate = employeeDto.HireDate,
            Salary = employeeDto.Salary,
            AddressLine1 = employeeDto.AddressLine1,
            AddressLine2 = employeeDto.AddressLine2,
            City = employeeDto.City,
            CreatedOn = employeeDto.CreatedOn,
            UpdatedOn = employeeDto.UpdatedOn,
            IsActive = true // Needs to be set explicitly if it's not nullable and has a default value
        };

        await _context.Employees.AddAsync(employee);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateEmployeeName(EmployeeUpdateNameDto employeeUpdate)
    {
        var employee = await _context.Employees.FindAsync(employeeUpdate.EmployeeID);
        if (employee != null)
        {
            employee.Name = employeeUpdate.Name;
            await _context.SaveChangesAsync();
        }
    }

    public async Task DeleteEmployeeById(EmployeeDeleteDto employeeDelete)
    {
        var employee = await _context.Employees.FindAsync(employeeDelete.EmployeeID);
        if (employee != null)
        {
            _context.Employees.Remove(employee);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<List<GetEmployeesByCityDto>> GetEmployeesByCity(EmployeeCityQueryDto cityQuery)
    {
        return await _context.Employees
                             .Where(e => e.City == cityQuery.City)
                             .Select(e => new GetEmployeesByCityDto(e.Id, e.Name, e.City))
                             .ToListAsync();
    }

    public async Task<List<ProjectDto>> GetProjectsByEmployeeId(EmployeeProjectsQueryDto employeeProjectsQuery)
    {
        return await _context.Projects
                             .Where(p => p.EmployeeAssigned == employeeProjectsQuery.EmployeeID)
                             .Select(p => new ProjectDto
                             {
                                 ProjectID = p.Id,
                                 Name = p.Name,
                                 StartDate = p.StartDate,
                                 EndDate = p.EndDate,
                                 Budget = p.Budget,
                                 Status = (byte)p.Status,
                                 LogoSvg = p.LogoSvg,
                                 Notes = p.Notes,
                                 Progress = p.Progress,
                                 Priority = (byte)p.Priority,
                                 EmployeeAssigned = p.EmployeeAssigned
                             })
                             .ToListAsync();
    }

    public async Task<List<ProjectDto>> GetProjectsByCustomerId(CustomerProjectsQueryDto customerProjectsQuery)
    {
        // Querying the database to find all projects associated with the given customer ID.
        var projects = await _context.Projects
            .Where(p => _context.ProjectCustomers
                .Any(pc => pc.CustomerId == customerProjectsQuery.CustomerID && pc.ProjectId == p.Id))
            .Select(p => new ProjectDto
            {
                ProjectID = p.Id,
                Name = p.Name,
                StartDate = p.StartDate,
                EndDate = p.EndDate,
                Budget = p.Budget,
                Status = (byte)p.Status, // Assuming you will convert the enum to its byte value here
                LogoSvg = p.LogoSvg,
                Notes = p.Notes,
                Progress = p.Progress,
                Priority = (byte)p.Priority, // Similarly, converting the enum to its byte value
                EmployeeAssigned = p.EmployeeAssigned,
                CreatedOn = p.CreatedOn,
                UpdatedOn = p.UpdatedOn
            })
            .ToListAsync();

        return projects;
    }

    public async Task<List<EmployeeDto>> FullTextSearch(FullTextSearchDto searchQuery)
    {
        var employees = await _context.Employees
            .Where(e => EF.Functions.FreeText(e.Name, searchQuery.SearchTerm) ||
                        EF.Functions.FreeText(e.Department, searchQuery.SearchTerm))
            .Select(e => new EmployeeDto
            {
                EmployeeID = e.Id,
                Name = e.Name,
                Age = e.Age,
                Gender = e.Gender,
                Department = e.Department,
                HireDate = e.HireDate,
                Salary = e.Salary ?? 0M, // Assuming Salary is a nullable decimal and providing a default value if null
                AddressLine1 = e.AddressLine1,
                AddressLine2 = e.AddressLine2,
                City = e.City
            })
            .ToListAsync();

        return employees;
    }

    public async Task<List<EmployeeProjectOuterJoinDto>> GetEmployeeProjectsWithOuterJoin()
    {
        // Query to perform a left outer join between Employees and Projects
        var query = from employee in _context.Employees
                    join project in _context.Projects
                    on employee.Id equals project.EmployeeAssigned into projectGroup
                    from subProject in projectGroup.DefaultIfEmpty() // Ensures it's a left outer join
                    select new EmployeeProjectOuterJoinDto
                    {
                        EmployeeID = employee.Id,
                        ProjectID = subProject != null ? subProject.Id : (Guid?)null
                    };

        return await query.ToListAsync();
    }


    public async Task<List<EmployeeSubqueryDto>> GetEmployeesWithSubquery()
    {
        // Define a threshold for project budgets
        var budgetThreshold = 100000M;

        var employeesWithHighBudgetProjects = await _context.Employees
            .Where(e => _context.Projects
                .Any(p => p.EmployeeAssigned == e.Id && p.Budget > budgetThreshold))
            .Select(e => new EmployeeSubqueryDto
            {
                EmployeeID = e.Id,
                Name = e.Name
            })
            .ToListAsync();

        return employeesWithHighBudgetProjects;
    }

    public async Task EditJsonData(EditJsonDataDto editJsonDataDto)
    {
        var customer = await _context.Customers
            .FirstOrDefaultAsync(c => c.Id == editJsonDataDto.EntityId);

        if (customer != null)
        {
            // Assuming JsonDataDto can be directly serialized into JSON string
            // You might need to adjust serialization settings based on your requirements
            customer.JSONData = JsonSerializer.Serialize(editJsonDataDto.UpdatedJsonData);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<List<CustomerBasedOnJsonPropertyDto>> SelectCustomersWithFavoriteNumber(int favoriteNumber)
    {
        return await _context.Customers
            .Where(c => EF.Functions.JsonContains(c.JSONData, JsonSerializer.Serialize(favoriteNumber), "$.FavoriteNumbers"))
            .Select(c => new CustomerBasedOnJsonPropertyDto
            {
                CustomerID = c.Id,
                Name = c.Name,
                Age = c.Age,
                Email = c.Email,
                PhoneNumber = c.PhoneNumber,
                AddressLine1 = c.AddressLine1,
                AddressLine2 = c.AddressLine2,
                City = c.City,
                Country = c.Country,
                GeographicLocation = c.GeographicLocation,
                LoyaltyPoints = c.LoyaltyPoints,
                LastPurchaseDate = c.LastPurchaseDate,
                Notes = c.Notes,
                JSONData = c.JSONData
            })
            .ToListAsync();
    }


    public async Task AppendNumberToJsonData(AppendNumberToJsonDataDto appendNumberDto)
    {
        var customer = await _context.Customers
            .FirstOrDefaultAsync(c => c.Id == appendNumberDto.EntityId);

        if (customer != null)
        {
            var jsonData = JsonSerializer.Deserialize<JsonDataDto>(customer.JSONData) ?? new JsonDataDto();
            jsonData.FavoriteNumbers.Add(appendNumberDto.NumberToAppend);
            customer.JSONData = JsonSerializer.Serialize(jsonData);
            await _context.SaveChangesAsync();
        }
    }


    public async Task<List<CustomerBasedOnJsonPropertyDto>> SelectCustomerBasedOnJsonProperty(JsonPropertyQueryDto jsonPropertyQuery)
    {
        var query = _context.Customers
            .Where(c => EF.Functions.JsonValue(c.JSONData, $"$.{jsonPropertyQuery.JsonPropertyName}") == jsonPropertyQuery.Value)
            .Select(c => new CustomerBasedOnJsonPropertyDto
            {
                CustomerID = c.Id,
                Name = c.Name,
                Age = c.Age,
                Email = c.Email,
                PhoneNumber = c.PhoneNumber,
                AddressLine1 = c.AddressLine1,
                AddressLine2 = c.AddressLine2,
                City = c.City,
                Country = c.Country,
                GeographicLocation = c.GeographicLocation,
                LoyaltyPoints = c.LoyaltyPoints,
                LastPurchaseDate = c.LastPurchaseDate,
                Notes = c.Notes,
                JSONData = c.JSONData
            });

        return await query.ToListAsync();
    }

    public async Task<List<EmployeeHierarchyDto>> GetEmployeeHierarchy(EmployeeHierarchyQueryDto hierarchyQuery)
    {
        var cteQuery = @"
WITH RECURSIVE EmployeeCTE AS (
    SELECT e.Id AS EmployeeId, e.Name AS EmployeeName, eh.ManagerId, m.Name AS ManagerName
    FROM Employees e
    LEFT JOIN EmployeeHierarchy eh ON e.Id = eh.EmployeeId
    LEFT JOIN Employees m ON eh.ManagerId = m.Id
    WHERE e.Id = {0}
    UNION ALL
    SELECT e.Id, e.Name, eh.ManagerId, m.Name
    FROM Employees e
    INNER JOIN EmployeeHierarchy eh ON e.Id = eh.EmployeeId
    INNER JOIN EmployeeCTE ecte ON eh.ManagerId = ecte.EmployeeId
    LEFT JOIN Employees m ON eh.ManagerId = m.Id
)
SELECT * FROM EmployeeCTE";

        var employeeHierarchies = await _context.EmployeeHierarchies
            .FromSqlRaw(cteQuery, hierarchyQuery.EmployeeID)
            .Select(eh => new EmployeeHierarchyDto
            {
                EmployeeId = eh.EmployeeId,
                ManagerId = eh.ManagerId,
                EmployeeName = eh.EmployeeName,
                ManagerName = eh.ManagerName
            }).ToListAsync();

        return employeeHierarchies;
    }


    public async Task AddEmployeeWithPartialData(EmployeePartialAddDto employeePartial)
    {
        var employee = new Employee
        {
            // Id is auto-generated by the database with DEFAULT newid(), no need to set it here.
            // modelBuilder.Entity<Employee>()
            // .Property(e => e.Id)
            // .HasDefaultValueSql("newid()");
            Name = employeePartial.Name,
            Age = employeePartial.Age,
            Department = "DefaultDepartment",
            HireDate = DateTime.UtcNow,

            CreatedOn = DateTime.UtcNow, // Explicitly set to ensure it matches the intended default behavior
                                         // or
                                         //    modelBuilder.Entity<Employee>()
                                         //       .Property(e => e.CreatedOn)
                                         //       .HasDefaultValueSql("SYSDATETIME()")
                                         //       .ValueGeneratedOnAdd();
            IsActive = true // Explicitly set to ensure it matches the intended default behavior
        };

        await _context.Employees.AddAsync(employee);
        await _context.SaveChangesAsync();
    }

    public async Task RunTwoUpdatesInSingleTransaction(SingleOperationTransactionDto data)
    {
        var transaction = _context.Database.BeginTransaction();
        try
        {
            var employee1 = await _context.Employees.FindAsync(data.Id1);
            if (employee1 != null)
            {
                employee1.Name = data.Name1;
            }

            var employee2 = await _context.Employees.FindAsync(data.Id2);
            if (employee2 != null)
            {
                employee2.Name = data.Name2;
            }

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
        finally
        {
            await transaction.DisposeAsync();
        }
    }

    public async Task BulkInsertEmployees(IEnumerable<EmployeeBulkInsertDto> employeeDtos)
    {
        // Use EF Core Bulk Extensions for more performance

        var employees = employeeDtos.Select(dto => new Employee
        {
            Id = dto.EmployeeID,
            Name = dto.Name,
            Age = dto.Age,
            Department = dto.Department,
            HireDate = dto.HireDate,
            Salary = dto.Salary,
            AddressLine1 = dto.AddressLine1,
            AddressLine2 = dto.AddressLine2,
            City = dto.City,
            CreatedOn = DateTime.UtcNow,
            IsActive = true
        });

        _context.ChangeTracker.AutoDetectChangesEnabled = false; // Improve performance for bulk insert

        await _context.Employees.AddRangeAsync(employees);
        await _context.SaveChangesAsync();

        _context.ChangeTracker.AutoDetectChangesEnabled = true; // Re-enable auto-detect changes after the bulk insert
    }

    public async Task BulkUpdateEmployees(IEnumerable<EmployeeBulkUpdateDto> employeeDtos)
    {
        // Use EF Core Bulk Extensions for more performance
        //      var employeesToUpdate = employeeDtos.Select(dto => new Employee
        // {
        //     Id = dto.EmployeeID,
        //     Name = dto.Name,
        // }).ToList();

        // await _context.BulkUpdateAsync(employeesToUpdate);

        _context.ChangeTracker.AutoDetectChangesEnabled = false; // Improve performance

        foreach (var dto in employeeDtos)
        {
            var employee = await _context.Employees.FindAsync(dto.EmployeeID);
            if (employee != null)
            {
                employee.Name = dto.Name;
                // Apply other updates as necessary
            }
        }

        await _context.SaveChangesAsync();
        _context.ChangeTracker.AutoDetectChangesEnabled = true;
    }

    public async Task<List<EmployeesWithDynamicQueryDto>> GetEmployeesWithDynamicQuery(DynamicQueryDto query)
    {
        // Starting with a base query
        IQueryable<Employee> baseQuery = _context.Employees;

        // Dynamically applying filters
        foreach (var filter in query.Filters)
        {
            switch (filter.Key.ToLower())
            {
                case "name":
                    baseQuery = baseQuery.Where(e => EF.Functions.Like(e.Name, $"%{filter.Value}%"));
                    break;
                case "department":
                    baseQuery = baseQuery.Where(e => EF.Functions.Like(e.Department, $"%{filter.Value}%"));
                    break;
                case "age":
                    if (filter.Value is int age)
                    {
                        baseQuery = baseQuery.Where(e => e.Age == age);
                    }
                    break;
                default:
                    break;
            }
        }

        // Preparing for sorting - defaulting to Name if no sort criteria provided
        var sortProperty = query.SortOrder.FirstOrDefault();
        if (string.IsNullOrEmpty(sortProperty.Key))
        {
            baseQuery = baseQuery.OrderBy(e => e.Name);
        }
        else
        {
            switch (sortProperty.Key.ToLower())
            {
                case "name":
                    baseQuery = sortProperty.Value ? baseQuery.OrderBy(e => e.Name) : baseQuery.OrderByDescending(e => e.Name);
                    break;
                case "age":
                    baseQuery = sortProperty.Value ? baseQuery.OrderBy(e => e.Age) : baseQuery.OrderByDescending(e => e.Age);
                    break;
                default:
                    baseQuery = baseQuery.OrderBy(e => e.Name); // Fallback sorting
                    break;
            }
        }

        // Projecting the final query to DTO
        var result = await baseQuery.Select(e => new EmployeesWithDynamicQueryDto
        {
            EmployeeID = e.Id,
            Name = e.Name,
            DynamicCriteria = query.Filters
        }).ToListAsync();

        return result;
    }


    public async Task<PagedResultDto<EmployeeDto>> GetEmployeesPagedAndSorted(PagingAndSortingQueryDto query)
    {
        // Base query from Employees table
        IQueryable<Employee> baseQuery = _context.Employees;

        // Applying sorting
        switch (query.SortBy.ToLower())
        {
            case "name":
                baseQuery = query.Ascending ? baseQuery.OrderBy(e => e.Name) : baseQuery.OrderByDescending(e => e.Name);
                break;
            case "department":
                baseQuery = query.Ascending ? baseQuery.OrderBy(e => e.Department) : baseQuery.OrderByDescending(e => e.Department);
                break;
            case "age":
                baseQuery = query.Ascending ? baseQuery.OrderBy(e => e.Age) : baseQuery.OrderByDescending(e => e.Age);
                break;
            // Default sorting by Name if no valid sort by provided
            default:
                baseQuery = baseQuery.OrderBy(e => e.Name);
                break;
        }

        // Count total items for pagination metadata before applying pagination
        int totalCount = await baseQuery.CountAsync();

        // Applying pagination
        var pagedQuery = baseQuery
            .Skip((query.PageNumber - 1) * query.PageSize)
            .Take(query.PageSize);

        // Projecting to DTO
        var items = await pagedQuery.Select(e => new EmployeeDto
        {
            EmployeeID = e.Id,
            Name = e.Name,
            Age = e.Age,
            Department = e.Department,
            HireDate = e.HireDate,
            Salary = e.Salary,
            AddressLine1 = e.AddressLine1,
            AddressLine2 = e.AddressLine2,
            City = e.City
        }).ToListAsync();

        // Constructing the result with pagination metadata
        var result = new PagedResultDto<EmployeeDto>(items, totalCount);

        return result;
    }

    public async Task<List<EmployeeSelfJoinDto>> GetEmployeeManagers()
    {
        // Performing a self-join on the Employees table to link each employee with their manager
        var query = from employee in _context.Employees
                    join manager in _context.Employees on employee.EmployeeHierarchy.ManagerId equals manager.Id into managerGroup
                    from m in managerGroup.DefaultIfEmpty() // This ensures that employees without managers are included in the results
                    select new EmployeeSelfJoinDto
                    {
                        EmployeeID = employee.Id,
                        ManagerID = m != null ? m.Id : (Guid?)null, // If there's no manager, ManagerID will be null
                        EmployeeName = employee.Name,
                        ManagerName = m != null ? m.Name : null // If there's no manager, ManagerName will be null
                    };

        return await query.ToListAsync();
    }

    public async Task<decimal> GetTotalBudgetForProjects()
    {
        // Calculate the total budget by summing the Budget column of all projects
        var totalBudget = await _context.Projects.SumAsync(p => p.Budget);

        return totalBudget;
    }

    public async Task<List<ProjectSummaryDto>> GetProjectSummaries()
    {
        return await _context.ProjectSummaries.ToListAsync();
    }

    public async Task<List<EmployeeDto>> CallStoredProcedure(StoredProcedureQueryDto query)
    {
        // Assuming the stored procedure name is "GetEmployeesByDepartment"
        var procedureName = "GetEmployeesByDepartment";
        var departmentParam = new Microsoft.Data.SqlClient.SqlParameter("@Department", query.Department);

        // Execute the stored procedure and map the results to the EmployeeDto
        var employees = await _context.Employees
            .FromSqlRaw($"EXEC {procedureName} @Department", departmentParam)
            .Select(e => new EmployeeDto
            {
                EmployeeID = e.Id,
                Name = e.Name,
                Age = e.Age,
                Department = e.Department,
                HireDate = e.HireDate,
                Salary = e.Salary,
                AddressLine1 = e.AddressLine1,
                AddressLine2 = e.AddressLine2,
                City = e.City
            }).ToListAsync();

        return employees;
    }



    public async Task<List<CustomerSpatialQueryDto>> GetCustomersNearLocation(SpatialQueryDto query)
    {
        // Ensure the geometry factory's SRID matches your database SRID for geographic locations.
        // 4326 is commonly used for GPS coordinates.
        var geometryFactory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);

        // Create a point representing the query location
        var queryLocation = geometryFactory.CreatePoint(new Coordinate(query.Longitude, query.Latitude));

        // Query customers within the specified distance from the query location
        var customers = await _context.Customers
            .Where(c => c.GeographicLocation.IsWithinDistance(queryLocation, query.Distance))
            .Select(c => new CustomerSpatialQueryDto
            {
                CustomerID = c.Id,
                Name = c.Name,
                Email = c.Email,
                PhoneNumber = c.PhoneNumber,
                AddressLine1 = c.AddressLine1,
                AddressLine2 = c.AddressLine2,
                City = c.City,
                Country = c.Country,
                GeographicLocation = c.GeographicLocation,
                LoyaltyPoints = c.LoyaltyPoints,
                LastPurchaseDate = c.LastPurchaseDate,
                Notes = c.Notes
            })
            .ToListAsync();

        return customers;
    }



}
```

EmployeeService.cs: ```public class EmployeeService
{
    private readonly IEmployeeProjectRepository _repository;
    private readonly ITransactionService _transactionService;

    public EmployeeService(ITransactionService transactionService, IEmployeeProjectRepository repository)
    {
        _transactionService = transactionService;
        _repository = repository;
    }

    public async Task UpdateTwoEmployeesInTransaction(Guid employeeId1, string newName1, Guid employeeId2, string newName2)
    {
        using var transaction = await _transactionService.BeginTransactionAsync();

        try
        {
            await _repository.Operation1InATransaction(employeeId1, newName1);
            await _repository.Operation2InATransaction(employeeId2, newName2);

            await transaction.CommitAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw; // Rethrow the exception for further handling
        }
    }
}
```

Entities.cs: ```using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using NetTopologySuite.Geometries;

public interface ITrackable
{
    DateTime CreatedOn { get; set; }
    DateTime? UpdatedOn { get; set; }
}

public enum ProjectStatus
{
    Planned,
    InProgress,
    Completed,
    OnHold
}

public enum ProjectPriority
{
    Low,
    Medium,
    High,
    Critical
}


[Table("Employees")]
public class Employee : ITrackable
{
    [Key]
    public Guid Id { get; set; } = Guid.NewGuid();

    public string Name { get; set; }

    public int? Age { get; set; }

    public string Department { get; set; }

    public DateTime HireDate { get; set; }

    [Column(TypeName = "decimal(19, 4)")]
    public decimal? Salary { get; set; }

    public string? AddressLine1 { get; set; }

    public string? AddressLine2 { get; set; }

    public string City { get; set; }

    public DateTime CreatedOn { get; set; }

    public DateTime? UpdatedOn { get; set; }

    public bool IsActive { get; set; }

    // Navigation properties
    public virtual ICollection<Project> AssignedProjects { get; set; } = new List<Project>();
    public virtual EmployeeHierarchy? EmployeeHierarchy { get; set; }
}





[Table("Projects")]
public class Project : ITrackable
{
    [Key]
    public Guid Id { get; set; } = Guid.NewGuid();

    public string Name { get; set; }

    public DateTime StartDate { get; set; }

    public DateTime EndDate { get; set; }

    [Column(TypeName = "decimal(19, 4)")]
    public decimal Budget { get; set; }

    public ProjectStatus Status { get; set; }

    public byte[] LogoSvg { get; set; }

    public string? Notes { get; set; }

    public float Progress { get; set; }

    public ProjectPriority Priority { get; set; }

    public Guid? EmployeeAssigned { get; set; }

    public DateTime CreatedOn { get; set; }

    public DateTime? UpdatedOn { get; set; }

    // Navigation properties
    [ForeignKey("EmployeeAssigned")]
    public virtual Employee? Employee { get; set; }
}






[Table("Customers")]
public class Customer : ITrackable
{
    [Key]
    public Guid Id { get; set; } = Guid.NewGuid();

    public string Name { get; set; }

    public int? Age { get; set; }

    public string Email { get; set; }

    public string? PhoneNumber { get; set; }

    public string? AddressLine1 { get; set; }

    public string? AddressLine2 { get; set; }

    public string City { get; set; }

    public string Country { get; set; }

    public Point? GeographicLocation { get; set; }

    public int LoyaltyPoints { get; set; }

    public DateTime? LastPurchaseDate { get; set; }

    public string? Notes { get; set; }

    [Column(TypeName = "nvarchar(max)")]
    public string JSONData { get; set; } = "{}";

    public DateTime CreatedOn { get; set; }

    public DateTime? UpdatedOn { get; set; }
}






[Table("ProjectCustomers")]
public class ProjectCustomer : ITrackable
{
    [Key, Column(Order = 0)]
    public Guid ProjectId { get; set; }

    [Key, Column(Order = 1)]
    public Guid CustomerId { get; set; }

    public DateTime StartDate { get; set; }

    public DateTime? EndDate { get; set; }

    public DateTime CreatedOn { get; set; }

    public DateTime? UpdatedOn { get; set; }



    // Navigation properties
    [ForeignKey("ProjectId")]
    public virtual Project Project { get; set; }

    [ForeignKey("CustomerId")]
    public virtual Customer Customer { get; set; }
}





[Table("EmployeeHierarchy")]
public class EmployeeHierarchy : ITrackable
{
    [Key]
    public Guid EmployeeId { get; set; }

    public Guid? ManagerId { get; set; }

    public DateTime CreatedOn { get; set; }

    public DateTime? UpdatedOn { get; set; }

    // Navigation properties
    [ForeignKey("EmployeeId")]
    public virtual Employee Employee { get; set; }

    [ForeignKey("ManagerId")]
    public virtual Employee? Manager { get; set; }
}
```

MigrationService.cs: ```using Microsoft.EntityFrameworkCore;
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

public class MigrationService
{
    private readonly AppDbContext _context;
    private readonly string _migrationScriptsPath;

    public MigrationService(AppDbContext context, string migrationScriptsPath)
    {
        _context = context;
        _migrationScriptsPath = migrationScriptsPath;
    }
    public async Task ApplyMigrations()
    {
        var instanceId = Guid.NewGuid().ToString(); // Unique identifier for this instance
        var migrationFiles = Directory.GetFiles(_migrationScriptsPath, "*.sql").OrderBy(f => f);
        var migrationFileNames = migrationFiles.Select(Path.GetFileName).ToHashSet();

        // Retrieve all migrations that have been applied from the database
        var appliedMigrations = await _context.AppliedMigrations.Select(m => m.ScriptName).ToListAsync();

        // Check if any applied migrations are missing from the disk
        var missingMigrations = appliedMigrations.Except(migrationFileNames).ToList();
        if (missingMigrations.Any())
        {
            throw new InvalidOperationException($"The following migrations have been applied to the database but are missing from disk: {string.Join(", ", missingMigrations)}");
        }

        foreach (var file in migrationFiles)
        {
            var scriptName = Path.GetFileName(file);
            var alreadyApplied = appliedMigrations.Contains(scriptName);
            if (!alreadyApplied)
            {
                if (await TryAcquireLockAsync(instanceId))
                {
                    try
                    {
                        // Start a transaction for each script execution
                        using (var transaction = await _context.Database.BeginTransactionAsync())
                        {
                            var script = await File.ReadAllTextAsync(file);
                            await _context.Database.ExecuteSqlRawAsync(script);

                            // Log the migration as applied
                            await _context.AppliedMigrations.AddAsync(new AppliedMigration
                            {
                                ScriptName = scriptName,
                                AppliedBy = instanceId,
                                AppliedAt = DateTime.UtcNow
                            });
                            await _context.SaveChangesAsync();

                            // Commit the transaction if script executes successfully
                            await transaction.CommitAsync();
                        }
                    }
                    catch (Exception ex)
                    {
                        // Rollback is handled automatically by the using statement if an exception occurs

                        // Release the lock in case of failure
                        await ReleaseLockAsync();

                        // Rethrow the exception to stop the application
                        throw new Exception($"Failed to apply migration script {scriptName}: {ex.Message}", ex);
                    }
                    finally
                    {
                        // Ensure the lock is released after attempting to apply the migration
                        await ReleaseLockAsync();
                    }
                }
            }
        }
    }


    public async Task<bool> TryAcquireLockAsync(string instanceId)
    {
        const int lockId = 1; // Assuming a single lock record with a known ID for simplicity

        // Start a transaction
        using (var transaction = await _context.Database.BeginTransactionAsync(System.Data.IsolationLevel.Serializable))
        {
            try
            {
                // Attempt to acquire the lock using UPDLOCK and ROWLOCK hints to prevent other transactions from modifying or reading the row
                var lockRecord = await _context.MigrationLocks
                    .FromSqlInterpolated($"SELECT * FROM MigrationLock WITH (UPDLOCK, ROWLOCK) WHERE LockId = {lockId}")
                    .FirstOrDefaultAsync();

                if (lockRecord == null)
                {
                    // Initialize lock record if not present
                    lockRecord = new MigrationLock { LockId = lockId, IsLocked = false, LockedBy = null, LockAcquiredAt = null };
                    _context.MigrationLocks.Add(lockRecord);
                    await _context.SaveChangesAsync();
                }

                if (!lockRecord.IsLocked)
                {
                    // Acquire the lock
                    lockRecord.IsLocked = true;
                    lockRecord.LockedBy = instanceId;
                    lockRecord.LockAcquiredAt = DateTime.UtcNow;
                    await _context.SaveChangesAsync();

                    // Commit the transaction to release the lock
                    await transaction.CommitAsync();

                    return true; // Successfully acquired the lock
                }

                // Lock is already held by another instance, do not commit the transaction
                return false;
            }
            catch
            {
                // Ensure the transaction is rolled back if an exception occurs
                await transaction.RollbackAsync();
                throw;
            }
        }
    }



    public async Task ReleaseLockAsync()
    {
        const int lockId = 1; // Assuming you're working with a single, known lock record

        // It's important to handle this operation as a transaction to ensure atomicity
        using (var transaction = await _context.Database.BeginTransactionAsync())
        {
            try
            {
                var lockRecord = await _context.MigrationLocks.FindAsync(lockId);
                if (lockRecord != null && lockRecord.IsLocked)
                {
                    // Release the lock
                    lockRecord.IsLocked = false;
                    lockRecord.LockedBy = null;
                    lockRecord.LockAcquiredAt = null;
                    await _context.SaveChangesAsync();

                    // Commit the transaction to finalize the lock release
                    await transaction.CommitAsync();
                }
            }
            catch
            {
                // Roll back the transaction if there's an error
                await transaction.RollbackAsync();
                throw; // Re-throw the exception to be handled by the caller
            }
        }
    }


}
```

Program.cs: ```var builder = WebApplication.CreateBuilder(args);

// Other configurations...

var connectionString = builder.Configuration.GetConnectionString("YourConnectionStringName");
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(connectionString, x => x.UseNetTopologySuite()));

// Read the migration scripts path from configuration
var migrationScriptsPath = builder.Configuration.GetValue<string>("MigrationSettings:ScriptsPath");

// Register the MigrationService with the DI container
builder.Services.AddScoped<MigrationService>(provider =>
    new MigrationService(
        provider.GetRequiredService<AppDbContext>(),
        migrationScriptsPath
    ));

builder.Services..AddScoped<ITransactionService, TransactionService>();

// Continue setting up the application...
var app = builder.Build();


// Apply migrations
using (var scope = app.Services.CreateScope())
{
    var migrationService = scope.ServiceProvider.GetRequiredService<MigrationService>();
    try
    {
        await migrationService.ApplyMigrations();
    }
    catch (Exception ex)
    {
        // Log the exception, perform any necessary cleanup, and stop application startup
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();
        logger.LogError(ex, "An error occurred while applying migrations. Application will be stopped.");

        // Fail fast by exiting the application
        Environment.Exit(1);
    }
}

// Further app configuration...

app.Run();
```

TransactionService.cs: ```public class TransactionService : ITransactionService
{
    private readonly AppDbContext _context;

    public TransactionService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<ITransaction> BeginTransactionAsync()
    {
        var transaction = await _context.Database.BeginTransactionAsync();
        return new EfCoreTransaction(transaction);
    }
}
```

appsettings.json: ```{
  "MigrationSettings": {
    "ScriptsPath": "Path\\To\\Your\\Scripts\\Folder"
  }
}
```

DapperMigrationService.cs: ```using System;
using System.Data;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Data.SqlClient;

// Basic version, EF Core version is more complete
public class DapperMigrationService
{
    private readonly string _connectionString;
    private readonly string _migrationScriptsPath;

    public DapperMigrationService(string connectionString, string migrationScriptsPath)
    {
        _connectionString = connectionString ?? throw new ArgumentNullException(nameof(connectionString));
        _migrationScriptsPath = migrationScriptsPath ?? throw new ArgumentNullException(nameof(migrationScriptsPath));
    }

    private IDbConnection CreateConnection() => new SqlConnection(_connectionString);

    public async Task ApplyMigrationsAsync()
    {
        var migrationFiles = Directory.GetFiles(_migrationScriptsPath, "*.sql").OrderBy(f => f);
        var appliedMigrations = await GetAppliedMigrationsAsync();

        foreach (var file in migrationFiles)
        {
            var scriptName = Path.GetFileName(file);
            if (!appliedMigrations.Contains(scriptName))
            {
                if (await TryAcquireLockAsync())
                {
                    try
                    {
                        var script = await File.ReadAllTextAsync(file);
                        using (var connection = CreateConnection())
                        {
                            await connection.ExecuteAsync(script);
                            await MarkMigrationAsAppliedAsync(scriptName);
                        }
                    }
                    finally
                    {
                        await ReleaseLockAsync();
                    }
                }
            }
        }
    }

    private async Task<bool> TryAcquireLockAsync()
    {
        const string acquireLockSql = @"
DECLARE @lockId INT = 1;
BEGIN TRANSACTION;
    IF NOT EXISTS (SELECT * FROM MigrationLock WITH (UPDLOCK, ROWLOCK) WHERE LockId = @lockId AND IsLocked = 1)
    BEGIN
        IF NOT EXISTS (SELECT * FROM MigrationLock WHERE LockId = @lockId)
        BEGIN
            INSERT INTO MigrationLock (LockId, IsLocked, LockedBy, LockAcquiredAt) VALUES (@lockId, 1, SYSTEM_USER, GETUTCDATE());
        END
        ELSE
        BEGIN
            UPDATE MigrationLock SET IsLocked = 1, LockedBy = SYSTEM_USER, LockAcquiredAt = GETUTCDATE() WHERE LockId = @lockId;
        END
        COMMIT;
        SELECT 1; -- Lock acquired
    END
    ELSE
    BEGIN
        ROLLBACK;
        SELECT 0; -- Lock not acquired
    END";

        using (var connection = CreateConnection())
        {
            var result = await connection.QuerySingleOrDefaultAsync<int>(acquireLockSql);
            return result == 1;
        }
    }

    private async Task ReleaseLockAsync()
    {
        const string releaseLockSql = @"
UPDATE MigrationLock SET IsLocked = 0, LockedBy = NULL, LockAcquiredAt = NULL WHERE LockId = 1";
        using (var connection = CreateConnection())
        {
            await connection.ExecuteAsync(releaseLockSql);
        }
    }

    private async Task<HashSet<string>> GetAppliedMigrationsAsync()
    {
        const string getAppliedMigrationsSql = @"
SELECT ScriptName FROM AppliedMigrations";
        using (var connection = CreateConnection())
        {
            var appliedMigrations = await connection.QueryAsync<string>(getAppliedMigrationsSql);
            return appliedMigrations.ToHashSet();
        }
    }

    private async Task MarkMigrationAsAppliedAsync(string scriptName)
    {
        const string markMigrationAsAppliedSql = @"
INSERT INTO AppliedMigrations (ScriptName, AppliedBy, AppliedAt) VALUES (@ScriptName, SYSTEM_USER, GETUTCDATE())";
        using (var connection = CreateConnection())
        {
            await connection.ExecuteAsync(markMigrationAsAppliedSql, new { ScriptName = scriptName });
        }
    }
}
```

DapperTransaction.cs: ```using System;
using System.Data;
using System.Threading.Tasks;

public class DapperTransaction : ITransaction
{
    private readonly IDbTransaction _transaction;
    private readonly IDbConnection _connection;
    private bool _disposed;

    public DapperTransaction(IDbConnection connection)
    {
        _connection = connection ?? throw new ArgumentNullException(nameof(connection));
        _connection.Open(); // Ensure the connection is open
        _transaction = _connection.BeginTransaction();
    }

    public async Task CommitAsync()
    {
        try
        {
            _transaction.Commit();
            await Task.CompletedTask; // Placeholder to match async signature
        }
        catch
        {
            // Optionally, log or handle errors here
            throw;
        }
    }

    public async Task RollbackAsync()
    {
        try
        {
            _transaction.Rollback();
            await Task.CompletedTask; // Placeholder to match async signature
        }
        catch
        {
            // Optionally, log or handle errors here
            throw;
        }
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                _transaction?.Dispose();
                _connection?.Close();
            }

            _disposed = true;
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
```

DatabaseConnectionFactory.cs: ```public class DatabaseConnectionFactory
{
    private readonly string _connectionString;

    public DatabaseConnectionFactory(string connectionString)
    {
        _connectionString = connectionString ?? throw new ArgumentNullException(nameof(connectionString));
        _connectionString = connectionString;
    }

    public IDbConnection CreateConnection()
        => new SqlConnection(_connectionString);
}
```

EmployeeProjectRepository.cs: ```using System;
using System.Collections.Generic;
using System.Data;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Data.SqlClient;

public class EmployeeProjectRepository : IEmployeeProjectRepository
{


    private readonly string _connectionString;
    // use this in stead 
    private readonly DatabaseConnectionFactory _connectionFactory;

    public EmployeeProjectRepository(DatabaseConnectionFactory connectionFactory)
    {
        _connectionFactory = connectionFactory;
    }

    private IDbConnection CreateConnection()
    {
        return _connectionFactory.CreateConnection();
    }

    private async Task ExecuteAsync(string sql, object param = null)
    {
        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();
            await connection.ExecuteAsync(sql, param);
        }
    }

    private async Task<List<T>> QueryAsync<T>(string sql, object param = null)
    {
        using (var connection = CreateConnection())
        {
            var results = await connection.QueryAsync<T>(sql, param);
            return results.ToList();
        }
    }

    public async Task AddEmployee(EmployeeAddDto employee)
    {
        var sql = @"
INSERT INTO Employees (Id, Name, Age, Department, HireDate, Salary, AddressLine1, AddressLine2, City, CreatedOn, UpdatedOn) 
VALUES (@EmployeeID, @Name, @Age, @Department, @HireDate, @Salary, @AddressLine1, @AddressLine2, @City, @CreatedOn, @UpdatedOn)";


        await ExecuteAsync(sql, new
        {
            employee.EmployeeID,
            employee.Name,
            employee.Age,
            employee.Department,
            employee.HireDate,
            employee.Salary,
            employee.AddressLine1,
            employee.AddressLine2,
            employee.City,
            employee.CreatedOn,
            employee.UpdatedOn
        });

    }
    public async Task UpdateEmployeeName(EmployeeUpdateNameDto employeeUpdate)
    {
        var sql = @"
UPDATE Employees 
SET Name = @Name 
WHERE Id = @EmployeeID";

        await ExecuteAsync(sql, new
        {
            employeeUpdate.EmployeeID,
            employeeUpdate.Name
        });
    }

    public async Task DeleteEmployeeById(EmployeeDeleteDto employeeDelete)
    {
        var sql = @"
DELETE FROM Employees 
WHERE Id = @EmployeeID";

        await ExecuteAsync(sql, new
        {
            employeeDelete.EmployeeID
        });
    }


    public async Task<List<GetEmployeesByCityDto>> GetEmployeesByCity(EmployeeCityQueryDto cityQuery)
    {
        var sql = @"
SELECT Id as EmployeeID, Name, City 
FROM Employees 
WHERE City = @City";

        return await QueryAsync<GetEmployeesByCityDto>(sql, new { cityQuery.City });
    }

    public async Task<List<ProjectDto>> GetProjectsByEmployeeId(EmployeeProjectsQueryDto employeeProjectsQuery)
    {
        var sql = @"
SELECT p.Id as ProjectID, p.Name, p.StartDate, p.EndDate, p.Budget, p.Status, p.LogoSvg, p.Notes, p.Progress, p.Priority, p.EmployeeAssigned
FROM Projects p
INNER JOIN EmployeeProjects ep ON p.Id = ep.ProjectId
WHERE ep.EmployeeId = @EmployeeID";

        return await QueryAsync<ProjectDto>(sql, new { employeeProjectsQuery.EmployeeID });
    }

    public async Task<List<ProjectDto>> GetProjectsByCustomerId(CustomerProjectsQueryDto customerProjectsQuery)
    {
        var sql = @"
SELECT p.Id as ProjectID, p.Name, p.StartDate, p.EndDate, p.Budget, p.Status, p.LogoSvg, p.Notes, p.Progress, p.Priority, p.EmployeeAssigned
FROM Projects p
WHERE p.CustomerId = @CustomerID";

        return await QueryAsync<ProjectDto>(sql, new { customerProjectsQuery.CustomerID });
    }

    public async Task<List<EmployeeDto>> FullTextSearch(FullTextSearchDto searchQuery)
    {
        // Assuming full-text search is set up on the Employees table, for columns like Name, Department, etc.
        var sql = @"
SELECT Id as EmployeeID, Name, Age, Department, HireDate, Salary, AddressLine1, AddressLine2, City 
FROM Employees 
WHERE CONTAINS((Name, Department, City), @SearchTerm)";

        // The @SearchTerm parameter should be formatted appropriately for full-text search.
        // For a simple search, you can use the search term directly. For more complex searches, you might need to format the search term (e.g., prefixing with '*', using BOOLEAN mode, etc.)
        var formattedSearchTerm = $"\"*{searchQuery.SearchTerm}*\""; // Simple formatting example. Adjust based on your needs and SQL Server's full-text search syntax.

        return await QueryAsync<EmployeeDto>(sql, new { SearchTerm = formattedSearchTerm });
    }

    public async Task<List<EmployeeProjectOuterJoinDto>> GetEmployeeProjectsWithOuterJoin()
    {
        var sql = @"
SELECT e.Id as EmployeeID, p.Id as ProjectID
FROM Employees e
LEFT OUTER JOIN EmployeeProjects ep ON e.Id = ep.EmployeeId
LEFT OUTER JOIN Projects p ON ep.ProjectId = p.Id";

        return await QueryAsync<EmployeeProjectOuterJoinDto>(sql);
    }

    public async Task<List<EmployeeSubqueryDto>> GetEmployeesWithSubquery()
    {
        // Define a threshold for project budgets
        var budgetThreshold = 100000M;

        var sql = @"
SELECT e.Id AS EmployeeID, e.Name
FROM Employees e
WHERE EXISTS (
    SELECT 1
    FROM Projects p
    WHERE p.EmployeeAssigned = e.Id AND p.Budget > @BudgetThreshold
)";

        return await QueryAsync<EmployeeSubqueryDto>(sql, new { BudgetThreshold = budgetThreshold });
    }


    public async Task EditJsonData(EditJsonDataDto editJsonDataDto)
    {
        var sql = @"
UPDATE YourTableName 
SET JSONData = @UpdatedJson 
WHERE Id = @EntityId";

        // Assuming the JsonDataDto's content is serialized to a JSON string for the update.
        // This serialization step depends on how your data is structured and may need adjustment.
        var updatedJson = JsonConvert.SerializeObject(editJsonDataDto.UpdatedJsonData);

        await ExecuteAsync(sql, new
        {
            EntityId = editJsonDataDto.EntityId,
            UpdatedJson = updatedJson
        });
    }

    public async Task AppendNumberToJsonData(AppendNumberToJsonDataDto appendNumberDto)
    {
        var sql = @"
UPDATE YourTableName
SET JSONData = JSON_MODIFY(JSONData, 'append $.FavoriteNumbers', @NumberToAppend)
WHERE Id = @EntityId";

        await ExecuteAsync(sql, new
        {
            EntityId = appendNumberDto.EntityId,
            NumberToAppend = appendNumberDto.NumberToAppend
        });
    }

    public async Task<List<CustomerBasedOnJsonPropertyDto>> SelectCustomerBasedOnJsonProperty(JsonPropertyQueryDto jsonPropertyQuery)
    {

        var allowedPropertyNames = new HashSet<string> { "Name", "Category" };

        // Validate user input against the whitelist
        if (!allowedPropertyNames.Contains(jsonPropertyQuery.JsonPropertyName))
        {
            throw new ArgumentException("Invalid JSON property name.");
        }

        var jsonPath = "$." + jsonPropertyQuery.JsonPropertyName;
        var sql = $@"
SELECT Id as CustomerID, Name, Age, Email, PhoneNumber, AddressLine1, AddressLine2, City, Country, GeographicLocation, LoyaltyPoints, LastPurchaseDate, Notes, JSONData
FROM Customers
WHERE JSON_VALUE(JSONData, @JsonPath) = @Value";


        return QueryAsync<CustomerBasedOnJsonPropertyDto>(sql, new
        {
            JsonPath = jsonPath, // JSON path is directly injected into SQL, ensure it's safe
            Value = jsonPropertyQuery.Value
        });

    }



    public async Task<List<CustomerBasedOnJsonPropertyDto>> SelectCustomersWithFavoriteNumber(int favoriteNumber)
    {
        var sql = @"
SELECT c.Id as CustomerID, c.Name, c.Age, c.Email, c.PhoneNumber, c.AddressLine1, c.AddressLine2, c.City, c.Country, c.GeographicLocation, c.LoyaltyPoints, c.LastPurchaseDate, c.Notes, c.JSONData
FROM Customers c
CROSS APPLY OPENJSON(c.JSONData, '$.FavoriteNumbers')
    WITH (Number int '$') AS favNumbers
WHERE favNumbers.Number = @FavoriteNumber";


        return await QueryAsync<CustomerBasedOnJsonPropertyDto>(sql, new { FavoriteNumber = favoriteNumber });
    }

    public async Task<List<EmployeeHierarchyDto>> GetEmployeeHierarchy(EmployeeHierarchyQueryDto hierarchyQuery)
    {
        var sql = @"
;WITH EmployeeCTE AS (
    SELECT e.Id, e.ManagerId, e.Name
    FROM Employees e
    WHERE e.Id = @EmployeeID
    UNION ALL
    SELECT e.Id, e.ManagerId, e.Name
    FROM Employees e
    INNER JOIN EmployeeCTE ecte ON e.Id = ecte.ManagerId
)
SELECT Id as EmployeeId, ManagerId, Name as EmployeeName
FROM EmployeeCTE";

        return await QueryAsync<EmployeeHierarchyDto>(sql, new { EmployeeID = hierarchyQuery.EmployeeID });
    }

    public async Task AddEmployeeWithPartialData(EmployeePartialAddDto employeePartial)
    {
        var sql = @"
INSERT INTO Employees (Id, Name, Age, Department, HireDate, CreatedOn, UpdatedOn, IsActive) 
VALUES (@EmployeeID, @Name, @Age, 'Not Specified', @HireDate, SYSDATETIME(), SYSDATETIME(), 1)";

        await ExecuteAsync(sql, new
        {
            EmployeeID = Guid.NewGuid(), // Assuming the ID is generated here rather than by the client.
            employeePartial.Name,
            employeePartial.Age,
            HireDate = DateTime.UtcNow // Assuming the hire date is set to the current date for demonstration.
                                       // 'Department' is set to 'Not Specified' as a placeholder. Adjust this based on your requirements.
        });
    }


    public async Task RunTwoUpdatesInSingleTransaction(SingleOperationTransactionDto data)
    {
        var updateSql = @"
UPDATE Employees 
SET Name = @Name 
WHERE Id = @EmployeeID";

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();
            using (var transaction = connection.BeginTransaction())
            {
                // First update operation
                await connection.ExecuteAsync(updateSql, new { EmployeeID = data.id1, Name = data.name1 }, transaction: transaction);

                // Second update operation
                await connection.ExecuteAsync(updateSql, new { EmployeeID = data.id2, Name = data.name2 }, transaction: transaction);

                // Commit transaction
                transaction.Commit();
            }
        }
    }

    public async Task Operation1InATransaction(Guid id, string name)
    {
        var sql = "UPDATE Employees SET Name = @Name WHERE Id = @Id";
        await ExecuteAsync(sql, new { Id = id, Name = name });
    }

    public async Task Operation2InATransaction(Guid id, string name)
    {
        var sql = "UPDATE Employees SET Name = @Name WHERE Id = @Id";
        await ExecuteAsync(sql, new { Id = id, Name = name });
    }

    public async Task BulkInsertEmployees(IEnumerable<EmployeeBulkInsertDto> employeeDtos)
    {
        // or very large datasets, consider using a library like Dapper.Contrib or Dapper Plus, or use the SQL Server specific SqlBulkCopy class for maximum performance.
        var sql = @"INSERT INTO Employees (Id, Name, Age, Department, HireDate, Salary, AddressLine1, AddressLine2, City) VALUES ";

        var parameters = new List<object>();
        var valuesList = new List<string>();
        int count = 0;

        foreach (var employee in employeeDtos)
        {
            count++;
            valuesList.Add($"(@Id{count}, @Name{count}, @Age{count}, @Department{count}, @HireDate{count}, @Salary{count}, @AddressLine1{count}, @AddressLine2{count}, @City{count})");

            parameters.Add(new
            {
                Id = employee.EmployeeID,
                Name = employee.Name,
                Age = employee.Age,
                Department = employee.Department,
                HireDate = employee.HireDate,
                Salary = employee.Salary,
                AddressLine1 = employee.AddressLine1,
                AddressLine2 = employee.AddressLine2,
                City = employee.City
            });
        }

        sql += string.Join(", ", valuesList);

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();
            await connection.ExecuteAsync(sql, parameters.ToArray());
        }
    }


    public async Task BulkUpdateEmployees(IEnumerable<EmployeeBulkUpdateDto> employeeDtos)
    {
        //  For more substantial performance improvements, especially with very large datasets, 
        //  consider using a library that supports efficient bulk operations with SQL Server, such as 
        //  Dapper Plus, or leveraging SqlBulkCopy with a temporary table and then performing 
        //  a bulk update from the temporary table to the target table.
        var sql = @"UPDATE Employees SET Name = @Name WHERE Id = @EmployeeID";

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();
            using (var transaction = connection.BeginTransaction())
            {
                foreach (var employee in employeeDtos)
                {
                    await connection.ExecuteAsync(sql, new { EmployeeID = employee.EmployeeID, Name = employee.Name }, transaction: transaction);
                }

                transaction.Commit();
            }
        }
    }

    public async Task<List<EmployeesWithDynamicQueryDto>> GetEmployeesWithDynamicQuery(DynamicQueryDto query)
    {
        var sqlBuilder = new SqlBuilder();
        var template = sqlBuilder.AddTemplate(@"
SELECT Id AS EmployeeID, Name
/**where**/
/**orderby**/
FROM Employees
");

        // Dynamically applying filters
        if (query.Filters != null)
        {
            foreach (var filter in query.Filters)
            {
                var columnName = filter.Key;
                var columnValue = filter.Value;
                if (columnValue != null)
                {
                    // Ensure to handle potential SQL injection by using parameters and not injecting values directly
                    sqlBuilder.Where($"{columnName} LIKE @Value", new { Value = $"%{columnValue}%" });
                }
            }
        }

        // Applying dynamic sorting
        if (query.SortOrder != null && query.SortOrder.Count > 0)
        {
            foreach (var sort in query.SortOrder)
            {
                var direction = sort.Value ? "ASC" : "DESC";
                sqlBuilder.OrderBy($"{sort.Key} {direction}");
            }
        }
        else
        {
            // Default sorting
            sqlBuilder.OrderBy("Name ASC");
        }

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();
            var results = await connection.QueryAsync<EmployeesWithDynamicQueryDto>(template.RawSql, template.Parameters);
            return results.ToList();
        }
    }

    public async Task<List<EmployeesWithDynamicQueryDto>> GetEmployeesWithDynamicQuery(DynamicQueryDto query)
    {
        var allowedColumns = new HashSet<string> { "Name", "Department", "Age", "City" }; // Define allowed column names

        // Validate column names in filters
        foreach (var filter in query.Filters.Keys)
        {
            if (!allowedColumns.Contains(filter))
            {
                throw new ArgumentException($"Invalid column name in filters: {filter}");
            }
        }

        // Validate column names in sort orders
        foreach (var sort in query.SortOrder.Keys)
        {
            if (!allowedColumns.Contains(sort))
            {
                throw new ArgumentException($"Invalid column name in sort order: {sort}");
            }
        }

        var sqlBuilder = new SqlBuilder();
        var template = sqlBuilder.AddTemplate(@"
SELECT Id AS EmployeeID, Name
/**where**/
/**orderby**/
FROM Employees
");

        // Dynamically applying filters
        foreach (var filter in query.Filters)
        {
            var columnName = filter.Key;
            var columnValue = filter.Value;
            sqlBuilder.Where($"{columnName} LIKE @Value", new { Value = $"%{columnValue}%" });
        }

        // Applying dynamic sorting
        foreach (var sort in query.SortOrder)
        {
            var columnName = sort.Key;
            var direction = sort.Value ? "ASC" : "DESC";
            sqlBuilder.OrderBy($"{columnName} {direction}");
        }

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();
            var results = await connection.QueryAsync<EmployeesWithDynamicQueryDto>(template.RawSql, template.Parameters);
            return results.ToList();
        }
    }


    public async Task<PagedResultDto<EmployeeDto>> GetEmployeesPagedAndSorted(PagingAndSortingQueryDto query)
    {
        var allowedSortColumns = new HashSet<string> { "Name", "Department", "Age", "City" }; // Define allowed sort columns

        // Validate the SortBy column
        if (!allowedSortColumns.Contains(query.SortBy))
        {
            throw new ArgumentException($"Invalid sort column: {query.SortBy}");
        }

        var sortDirection = query.Ascending ? "ASC" : "DESC";

        // Building the SQL for paging and sorting
        var sql = $@"
SELECT Id, Name, Age, Department, HireDate, Salary, AddressLine1, AddressLine2, City
FROM Employees
ORDER BY {query.SortBy} {sortDirection}
OFFSET @Offset ROWS FETCH NEXT @PageSize ROWS ONLY;

SELECT COUNT(*) FROM Employees;";

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();

            // Using Dapper's QueryMultipleAsync to execute both queries in a single round trip
            using (var multi = await connection.QueryMultipleAsync(sql, new { Offset = (query.PageNumber - 1) * query.PageSize, PageSize = query.PageSize }))
            {
                var employees = (await multi.ReadAsync<EmployeeDto>()).ToList();
                var totalCount = await multi.ReadFirstAsync<int>();

                return new PagedResultDto<EmployeeDto>(employees, totalCount);
            }
        }
    }

    public async Task<List<EmployeeSelfJoinDto>> GetEmployeeManagers()
    {
        // SQL query that performs a self-join on the Employees table
        // to find the manager for each employee
        var sql = @"
SELECT e.Id AS EmployeeID, 
       m.Id AS ManagerID, 
       e.Name AS EmployeeName, 
       m.Name AS ManagerName
FROM Employees e
LEFT JOIN Employees m ON e.ManagerId = m.Id";

        return await QueryAsync<EmployeeSelfJoinDto>(sql);

    }

    public async Task<decimal> GetTotalBudgetForProjects()
    {
        // SQL query to calculate the total budget by summing the Budget column of all projects
        var sql = @"
SELECT SUM(Budget) 
FROM Projects";

        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();

            // Execute the query using Dapper. Use QuerySingleOrDefaultAsync to expect a single return value or default if none
            var totalBudget = await connection.QuerySingleOrDefaultAsync<decimal?>(sql);

            // Return 0 if the result is null (e.g., no projects in the table), otherwise return the total budget
            return totalBudget ?? 0;
        }
    }

    public async Task<List<ProjectSummaryDto>> GetProjectSummaries()
    {
        var sql = @"
SELECT 
    ProjectID,
    Name,
    TotalBudget,
    Status,
    StartDate,
    EndDate,
    Progress,
    Priority,
    EmployeeAssignedName,
    NumberOfCustomers
FROM ProjectSummaries;";

        return await QueryAsync<ProjectSummaryDto>(sql);
    }

    public async Task<List<EmployeeDto>> CallStoredProcedure(StoredProcedureQueryDto query)
    {
        // Define the stored procedure name
        var procedureName = "GetEmployeesByDepartment";

        // Create a new connection
        using (var connection = CreateConnection())
        {
            await connection.OpenAsync();

            // Define the parameters for the stored procedure
            var parameters = new DynamicParameters();
            parameters.Add("@Department", query.Department, DbType.String, ParameterDirection.Input);

            // Execute the stored procedure and map the results to a list of EmployeeDto
            var employees = await connection.QueryAsync<EmployeeDto>(procedureName, parameters, commandType: CommandType.StoredProcedure);

            return employees.ToList();
        }
    }

    public async Task<List<CustomerSpatialQueryDto>> GetCustomersNearLocation(SpatialQueryDto query)
    {
        // Define the SQL query to select customers near the specified location
        var sql = @"
DECLARE @queryPoint geography = geography::Point(@Latitude, @Longitude, 4326);
SELECT 
    Id as CustomerID, 
    Name, 
    Email, 
    PhoneNumber, 
    AddressLine1, 
    AddressLine2, 
    City, 
    Country, 
    GeographicLocation.ToString() as GeographicLocation, 
    LoyaltyPoints, 
    LastPurchaseDate, 
    Notes 
FROM 
    Customers 
WHERE 
    GeographicLocation.STDistance(@queryPoint) <= @Distance";

        return await QueryAsync<CustomerSpatialQueryDto>(sql, new
        {
            query.Latitude,
            query.Longitude,
            query.Distance
        });


    }


}
```

EmployeeService.cs: ```public class EmployeeService
{
    private readonly IEmployeeProjectRepository _repository;
    private readonly ITransactionService _transactionService;

    public EmployeeService(ITransactionService transactionService, IEmployeeProjectRepository repository)
    {
        _transactionService = transactionService;
        _repository = repository;
    }

    public async Task UpdateTwoEmployeesInTransaction(Guid employeeId1, string newName1, Guid employeeId2, string newName2)
    {
        using var transaction = await _transactionService.BeginTransactionAsync();

        try
        {
            await _repository.Operation1InATransaction(employeeId1, newName1);
            await _repository.Operation2InATransaction(employeeId2, newName2);

            await transaction.CommitAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw; // Rethrow the exception for further handling
        }
    }
}
```

Program.cs: ```using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using System;

var builder = WebApplication.CreateBuilder(args);

// Configuration for the connection string
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

// Register the DatabaseConnectionFactory as a singleton to be used by repositories
builder.Services.AddSingleton(new DatabaseConnectionFactory(connectionString));

// Register your Dapper-based repositories as scoped or transient as needed
// Assuming there is a repository interface IEmployeeProjectRepository and its implementation EmployeeProjectRepository
builder.Services.AddScoped<IEmployeeProjectRepository, EmployeeProjectRepository>();

// Register the custom migration service that uses Dapper to apply migrations
builder.Services.AddScoped<DapperMigrationService>();

var app = builder.Build();

// Apply migrations using the custom migration service
using (var scope = app.Services.CreateScope())
{
    var migrationService = scope.ServiceProvider.GetRequiredService<DapperMigrationService>();
    try
    {
        await migrationService.ApplyMigrationsAsync();
    }
    catch (Exception ex)
    {
        // Log the exception and possibly stop the application
        var logger = scope.ServiceProvider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<Program>>();
        logger.LogError(ex, "An error occurred while applying migrations.");

        // Depending on your application's needs, you might want to stop the application startup process here
        Environment.Exit(1);
    }
}

// Add services to the container.
builder.Services.AddControllersWithViews();

// Further configuration goes here

app.Run();
```

TransactionService.cs: ```using System.Data;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient; // Or the appropriate namespace for your DB provider

public class TransactionService : ITransactionService
{
    private readonly string _connectionString;

    public TransactionService(string connectionString)
    {
        _connectionString = connectionString ?? throw new ArgumentNullException(nameof(connectionString));
    }

    public async Task<ITransaction> BeginTransactionAsync()
    {
        // Create and open a new database connection
        IDbConnection connection = new SqlConnection(_connectionString);

        // Ensuring the connection is open before starting a transaction is important,
        // but since we're returning a DapperTransaction that opens the connection in its constructor,
        // we don't need to open it here. DapperTransaction will handle it.
        // This is a placeholder to match async signature. In a real-world scenario, you might directly open the connection asynchronously if your DB driver supports it.
        await Task.CompletedTask;

        // Initialize a new DapperTransaction which will manage the IDbTransaction lifecycle
        return new DapperTransaction(connection);
    }
}
```

IRepo.cs: ```using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using NetTopologySuite.Geometries;

public interface IEmployeeProjectRepository
{
    // Adds a new employee to the database.
    Task AddEmployee(EmployeeAddDto employee);

    // Updates the name of an employee based on the provided employee ID.
    Task UpdateEmployeeName(EmployeeUpdateNameDto employeeUpdate);

    // Deletes an employee from the database based on the provided employee ID.
    Task DeleteEmployeeById(EmployeeDeleteDto employeeDelete);

    // Retrieves a list of employees based on the provided city.
    Task<List<GetEmployeesByCityDto>> GetEmployeesByCity(EmployeeCityQueryDto cityQuery);

    // Retrieves a list of projects assigned to a specific employee.
    Task<List<ProjectDto>> GetProjectsByEmployeeId(EmployeeProjectsQueryDto employeeProjectsQuery);

    // Retrieves a list of projects associated with a specific customer.
    Task<List<ProjectDto>> GetProjectsByCustomerId(CustomerProjectsQueryDto customerProjectsQuery);

    // Performs a full-text search across relevant tables/columns.
    Task<List<EmployeeDto>> FullTextSearch(FullTextSearchDto searchQuery);

    // Demonstrates the use of an outer join in a query.
    Task<List<EmployeeProjectOuterJoinDto>> GetEmployeeProjectsWithOuterJoin();

    // Showcases a select within a select query.
    Task<List<EmployeeSubqueryDto>> GetEmployeesWithSubquery();

    // Edits the entire JSONData column for a specific entity.
    Task EditJsonData(EditJsonDataDto editJsonDataDto);

    // Appends a number to the favoriteNumbers array within the JSONData column of a specific entity.
    Task AppendNumberToJsonData(AppendNumberToJsonDataDto appendNumberDto);

    // Selects based on a property within a JSON column.
    Task<List<CustomerBasedOnJsonPropertyDto>> SelectCustomerBasedOnJsonProperty(JsonPropertyQueryDto jsonPropertyQuery);

    // Example method for selecting entities based on a condition within JSONData
    Task<List<CustomerBasedOnJsonPropertyDto>> SelectCustomersWithFavoriteNumber(int favoriteNumber);

    // Demonstrates the use of Common Table Expressions (CTE).
    Task<List<EmployeeHierarchyDto>> GetEmployeeHierarchy(EmployeeHierarchyQueryDto hierarchyQuery);

    // Demonstrates handling of partial object creation, specifically with the IsActive flag.
    Task AddEmployeeWithPartialData(EmployeePartialAddDto employeePartial);

    // Executes two different updates in a single transaction.
    Task RunTwoUpdatesInSingleTransaction(SingleOperationTransactionDto data);



    // Executes a single operation within a transaction.
    Task Operation1InATransaction(Guid id, string name);

    // Executes a single operation within a transaction.
    Task Operation2InATransaction(Guid id, string name);

    // Inserts a bulk list of entities efficiently.
    Task BulkInsertEmployees(IEnumerable<EmployeeBulkInsertDto> employees);

    // Updates a bulk list of entities efficiently.
    Task BulkUpdateEmployees(IEnumerable<EmployeeBulkUpdateDto> employees);

    // Dynamically generates a query based on a set of filters and sort criteria.
    Task<List<EmployeesWithDynamicQueryDto>> GetEmployeesWithDynamicQuery(DynamicQueryDto query);

    // Retrieves a paginated list of employees with sorting.
    Task<PagedResultDto<EmployeeDto>> GetEmployeesPagedAndSorted(PagingAndSortingQueryDto query);

    // Demonstrates the use of a self-join.
    Task<List<EmployeeSelfJoinDto>> GetEmployeeManagers();

    // Uses an aggregate function in a query.
    Task<decimal> GetTotalBudgetForProjects();

    // Selects data from a view.
    Task<List<ProjectSummaryDto>> GetProjectSummaries();

    // Calls a stored procedure and handles its results.
    Task<List<EmployeeDto>> CallStoredProcedure(StoredProcedureQueryDto query);

    // Performs a spatial data selection, e.g., finding customers within a certain distance.
    Task<List<CustomerSpatialQueryDto>> GetCustomersNearLocation(SpatialQueryDto query);
}

public interface ITransaction : IDisposable
{
    Task CommitAsync();
    Task RollbackAsync();
}


public interface ITransactionService
{
    Task<ITransaction> BeginTransactionAsync();

}



public record JsonDataDto
{
    public string Name { get; init; }
    public string? Category { get; init; }
    public List<int> FavoriteNumbers { get; init; } = new();
}

public record EditJsonDataDto(
    [Required] Guid EntityId,
    [Required] JsonDataDto UpdatedJsonData
);

public record AppendNumberToJsonDataDto(
    [Required] Guid EntityId,
    [Required, Range(0, int.MaxValue)] int NumberToAppend
); public record EmployeeAddDto(
    [Required] Guid EmployeeID,
    [Required, StringLength(50)] string Name,
    [Required, Range(1, 120)] int Age,
    [Required, StringLength(20)] string Department,
    [Required] DateTime HireDate,
    [Required, Range(0.01, double.MaxValue)] decimal Salary,
    StringLength(50)] string? AddressLine1,
    [StringLength(50)] string? AddressLine2,
    [Required, StringLength(30)] string City,
    [Required] DateTime CreatedOn,
    DateTime? UpdatedOn
);

public record EmployeeUpdateNameDto(
    [Required] Guid EmployeeID,
    [Required, StringLength(50)] string Name
);

public record EmployeeDeleteDto([Required] Guid EmployeeID);

public record EmployeeCityQueryDto([Required, StringLength(30)] string City);

public record EmployeeProjectsQueryDto([Required] Guid EmployeeID);

public record CustomerProjectsQueryDto([Required] Guid CustomerID);

public record FullTextSearchDto([Required] string SearchTerm);

public record EmployeeProjectOuterJoinDto(Guid EmployeeID, Guid? ProjectID);

public record EmployeeSubqueryDto(Guid EmployeeID, string Name);

public record JsonEditDto(
    [Required] Guid EntityID,
    [Required, StringLength(50)] string JsonPropertyName,
    [Required] string NewValue
);

public record JsonPropertyQueryDto(
    [Required, StringLength(50)] string JsonPropertyName,
    [Required] string Value
);

public record EmployeeHierarchyQueryDto([Required] Guid EmployeeID);

public record EmployeePartialAddDto(
    [Required, StringLength(50)] string Name,
    [Required, Range(1, 120)] int Age
);

public record EmployeeBulkInsertDto(IEnumerable<EmployeeAddDto> Employees);

public record EmployeeBulkUpdateDto(IEnumerable<EmployeeUpdateNameDto> Employees);

public record DynamicQueryDto(
    [Required] Dictionary<string, object?> Filters,
    [Required] Dictionary<string, bool> SortOrder
);

public record PagingAndSortingQueryDto(
    [Required, Range(1, int.MaxValue)] int PageNumber,
    [Required, Range(1, 100)] int PageSize,
    [Required] string SortBy,
    [Required] bool Ascending
);

public record EmployeeSelfJoinDto(
    [Required] Guid EmployeeID,
    Guid? ManagerID
);

public record ProjectSummaryDto(
    [Required] Guid ProjectID,
    [Required, StringLength(50)] string Name,
    [Required, Range(0.01, double.MaxValue)] decimal TotalBudget,
    [Required] byte Status,
    [Required] DateTime StartDate,
    [Required] DateTime EndDate,
    [Required] float Progress,
    [Required] byte Priority,
    [StringLength(50)] string EmployeeAssignedName,
    [Required, Range(0, int.MaxValue)] int NumberOfCustomers
);


public record StoredProcedureQueryDto([Required, StringLength(20)] string Department);

public record SpatialQueryDto(
    [Required, Range(-90, 90)] double Latitude,
    [Required, Range(-180, 180)] double Longitude,
    [Required, Range(0, double.MaxValue)] double Distance
);


public record EmployeeDto(
    Guid EmployeeID,
    string Name,
    int? Age,
    string Department,
    DateTime HireDate,
    decimal? Salary,
    string? AddressLine1,
    string? AddressLine2,
    string City);

public record ProjectDto(
    Guid ProjectID,
    string Name,
    DateTime StartDate,
    DateTime EndDate,
    decimal Budget,
    byte Status,
    byte[] LogoSvg,
    string? Notes,
    float Progress,
    byte Priority,
    Guid? EmployeeAssigned);

public record CustomerBasedOnJsonPropertyDto(
    Guid CustomerID,
    string Name,
    int? Age,
    string Email,
    string PhoneNumber,
    string? AddressLine1,
    string? AddressLine2,
    string City,
    string Country,
    Point? GeographicLocation,
    int LoyaltyPoints,
    DateTime? LastPurchaseDate,
    string? Notes,
    string JSONData);

public record GetEmployeesByCityDto(Guid EmployeeID, string Name, string City);

public record EmployeesWithDynamicQueryDto(Guid EmployeeID, string Name, Dictionary<string, object?> DynamicCriteria);

public record PagedResultDto<T>(IEnumerable<T> Items, int TotalCount) where T : class;


public record EmployeeHierarchyDto
{
    public Guid EmployeeId { get; init; }
    public Guid? ManagerId { get; init; }
    public string EmployeeName { get; init; }
    public string? ManagerName { get; init; }
}

public record SingleOperationTransactionDto(
    [Required] Guid id1,
    [Required, StringLength(50)] string name1,
    [Required] Guid id2,
    [Required, StringLength(50)] string name2
);

public record CustomerSpatialQueryDto(
     Guid CustomerID,
     string Name,
     string Email,
     string PhoneNumber,
     string? AddressLine1,
     string? AddressLine2,
     string City,
     string Country,
    Point? GeographicLocation,
     int LoyaltyPoints,
    DateTime? LastPurchaseDate,
    string? Notes
);```

schema.sql: ```CREATE TABLE Employees (
    Id uniqueidentifier NOT NULL PRIMARY KEY DEFAULT newid(),
    Name nvarchar(50) NOT NULL,
    Age int,
    Department nvarchar(20) NOT NULL,
    HireDate datetime2 NOT NULL,
    Salary decimal(19,4),
    AddressLine1 nvarchar(50),
    AddressLine2 nvarchar(50),
    City nvarchar(30),
    CreatedOn datetime2 NOT NULL DEFAULT SYSDATETIME(),
    UpdatedOn datetime2  NOT NULL DEFAULT SYSDATETIME(),
    IsActive bit NOT NULL DEFAULT 1
);

CREATE TABLE Projects (
    Id uniqueidentifier NOT NULL PRIMARY KEY DEFAULT newid(),
    Name nvarchar(50) NOT NULL,
    StartDate datetime2 NOT NULL,
    EndDate datetime2 NOT NULL,
    Budget decimal(19,4) NOT NULL,
    Status tinyint NOT NULL,
    LogoSvg varbinary(MAX) NOT NULL,
    Notes nvarchar(MAX),
    Progress float NOT NULL,
    Priority tinyint NOT NULL,
    EmployeeAssigned uniqueidentifier,
    FOREIGN KEY (EmployeeAssigned) REFERENCES Employees(Id),
    CreatedOn datetime2 NOT NULL DEFAULT SYSDATETIME(),
    UpdatedOn datetime2  NOT NULL DEFAULT SYSDATETIME()
);

CREATE TABLE Customers (
    Id uniqueidentifier NOT NULL PRIMARY KEY DEFAULT newid(),
    Name nvarchar(50) NOT NULL,
    Age int,
    Email nvarchar(254) NOT NULL,
    PhoneNumber nvarchar(15),
    AddressLine1 nvarchar(50),
    AddressLine2 nvarchar(50),
    City nvarchar(30) NOT NULL,
    Country nvarchar(25) NOT NULL,
    GeographicLocation geography,
    LoyaltyPoints int NOT NULL,
    LastPurchaseDate datetime2,
    Notes nvarchar(MAX),
    JSONData nvarchar(max) NOT NULL DEFAULT '{}',
    CreatedOn datetime2 NOT NULL DEFAULT SYSDATETIME(),
    UpdatedOn datetime2  NOT NULL DEFAULT SYSDATETIME()
);

CREATE TABLE ProjectCustomers (
    ProjectId uniqueidentifier NOT NULL,
    CustomerId uniqueidentifier NOT NULL,
    StartDate date NOT NULL,
    EndDate date NULL,
    FOREIGN KEY (ProjectId) REFERENCES Projects(Id),
    FOREIGN KEY (CustomerId) REFERENCES Customers(Id),
    PRIMARY KEY (ProjectId, CustomerId),
    CreatedOn datetime2 NOT NULL DEFAULT SYSDATETIME(),
    UpdatedOn datetime2  NOT NULL DEFAULT SYSDATETIME()
);

CREATE TABLE EmployeeHierarchy (
    EmployeeId uniqueidentifier NOT NULL,
    ManagerId uniqueidentifier NULL,
    FOREIGN KEY (EmployeeId) REFERENCES Employee(Id),
    FOREIGN KEY (ManagerId) REFERENCES Employee(Id),
    PRIMARY KEY (EmployeeId),
    CreatedOn datetime2 NOT NULL DEFAULT SYSDATETIME(),
    UpdatedOn datetime2  NOT NULL DEFAULT SYSDATETIME()
);

CREATE VIEW ProjectSummaries AS
SELECT
    p.Id AS ProjectID,
    p.Name,
    p.Budget AS TotalBudget,
    p.Status,
    p.StartDate,
    p.EndDate,
    p.Progress,
    p.Priority,
    e.Name AS EmployeeAssignedName,
    (SELECT COUNT(*) FROM ProjectCustomers WHERE ProjectId = p.Id) AS NumberOfCustomers
FROM
    Projects p
LEFT JOIN Employees e ON p.EmployeeAssigned = e.Id;


CREATE PROCEDURE GetEmployeesByDepartment
    @Department NVARCHAR(20)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT
        Id AS EmployeeID,
        Name,
        Age,
        Department,
        HireDate,
        Salary,
        AddressLine1,
        AddressLine2,
        City
    FROM Employees
    WHERE Department = @Department
END


CREATE TABLE AppliedMigrations (
    MigrationId INT IDENTITY(1,1) PRIMARY KEY,
    ScriptName VARCHAR(255) NOT NULL,
    AppliedBy VARCHAR(255) NOT NULL,
    AppliedAt DATETIME NOT NULL
);


CREATE TABLE MigrationLock (
    LockId INT PRIMARY KEY,
    IsLocked BIT NOT NULL,
    LockedBy VARCHAR(255),
    LockAcquiredAt DATETIME
);


```


I'm writing a demo app to compare different data access packages. I already implemented EF Core and now I want to create similar code with Dapper. MS SQL Server is the database.
